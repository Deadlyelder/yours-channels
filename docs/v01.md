## Formal Languages

A *formal language* is a set of words, where a word is a sequence of symbols like *abab*. An example of a formal language is *{abab, ababab, abcdef}*, the set of words of even length, or the set of pairs *(x,y,z)* such that z=x+y.

A machine is said to *decide* a language if given a word, it can decide if that word is an element of the language. Deciding a language requires computation, for example given *(x,y,z)* one has to compute x+y to determine whether *(x,y,z)* is in the "addition language" described in the above paragraph.

## Transaction chains

Let *t<sub>1</sub>, t<sub>2</sub>, t<sub>3</sub>, ...* be a chain of transactions, each with a single input and a single output. By "chain" we mean that the (single) output of *t<sub>i</sub>* is spent by the single input of *t<sub>i+1</sub>*. We denote the input script if *t<sub>i</sub>* by *in<sub>i</sub>* and it's output script by *out<sub>i</sub>*.

Note that the scripts are evaluated in the following order

in<sub>1</sub> out<sub>0</sub> | in<sub>2</sub> out<sub>1</sub> | in<sub>2</sub> out<sub>1</sub> | in<sub>2</sub> out<sub>1</sub> | ...

The vertical bars "|" illustrate the fact that the stack is cleared after evaluating the output scripts.

### Accepting formal languages in Bitcoin script

We will say that Bitcoin script can accept a language if there is a transaction chain *t<sub>1</sub>, t<sub>2</sub>, t<sub>3</sub>, ..., t<sub>n</sub>* such that t<sub>n</sub> is spendable if and only if in<sub>1</sub> pushes a word to the stack that belongs to the language

### Accepting the language "even"

To accept the word *aa* we construct the following sequence of transactions:

 * *in<sub>1</sub>*: Push the *aa* onto the "word stack" and "even" onto the "state stack".
 * *out<sub>0</sub>*: Check that *aa* is on the word stack and that "even" is on the state stack

At this point the stacks are reset.

 * *in<sub>2</sub>*: Push the *a* onto the "word stack" and "odd" onto the "state stack".
 * *out<sub>1</sub>*: Check that *a* is on the word stack and that "odd" is on the state stack

At this point the stacks are reset.

 * *in<sub>3</sub>*: Push the nothing onto the "word stack" and "even" onto the "state stack".
 * *out<sub>2</sub>*: Check that the word stack is empty and that "even" is on the state stack. Make this output spendable by the payee.

We need an "outer loop" that scans the blockchain to find a transaction with output *out<sub>0</sub>*. If such a transaction appears, the outer loop pushes transactions *t<sub>1</sub>, t<sub>2</sub>, t<sub>3</sub>* to the blockchain with the scripts above.

The outputs of transactions *t<sub>0</sub>, t<sub>1</sub>, t<sub>2</sub>* are spendable only by the payer, while the last transaction is spendable by the payee.

The above construction can be used to build a smart contract as follows:

![alt text](./img/smart-contract.jpg "smart-contract.jpg")
